## 자바 메모리 구조
### 비유
- 메서드 영역 : 클래스 정보를 보관한다
- 스택 영역 : 실제 프로그램이 실행되는 영역, 메서드를 실행할 때 마다 하나씩 쌓인다
- 힙 영역 : 객체(인스턴스)가 생성되는 영역, new 명령어를 사용하면 이 영역을 사용, 배열도 이 영역에 생성

### 실제
#### 메서드 영역 (Method Area)
*메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 이 영역은 프로그램의 모든 영역에서 공유*
- 클래스 정보 : 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등 모든 실행 코드 존재
- static 영역 : static 변수들을 보관한다.
- 런타임 상수 풀 : 프로그램을 실행하는데 필요한 공통 리터럴 상수 보관 -> "hello"라는 리터럴 문자가 있으면 이런 문자를 공통으로 묶어서 관리, 이 외에도 프로그램을 효율적으로 관리하기 위한 상수들을 관리

#### 스택 영역 (Stack Area)
*자바 실행 시, 하나의 실행 스택이 생성됨, 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보등을 포함*
- 스택 프레임 : 메서드를 호출할 때 마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거
- 스택 영역은 각 쓰레드 별로 하나의 실행 스택이 생성됨 -> 쓰레드 수 만큼 스택 영역이 생성됨

#### 힙 영역 (Heap Area)
*객체(인스턴스)와 배열이 생성되는 영역, GC가 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거됨*

100개의 인스턴스를 생성하면 힙 메모리에 100개의 인스턴스가 생성된다. 각각의 인스턴스는 내부에 변수와 메서드를 가진다.
같은 클래스로부터 생성된 객체이지만 인스턴스 내부의 변수값은 모두 다르다. 하지만 메서드는 공통된 코드를 공유한다.
따라서 인스턴스 변수는 새로 메모리가 할당 되지만 메서드에 대한 새로운 메모리 할당은 없으며 메서드는 메서드 영역에서 공통으로 관리 되고 실행된다.

지역 변수는 스택영역, 객체(인스턴스)는 힙 영역에 관리된다.

```java
public class Data3 {
    public String name;
    public static int count;
}
```
name, count는 둘다 멤버 변수
static에 따라 다음과 같이 분류
- 인스턴스 변수 : static이 붙지 않은 멤버 변수 -> name
  - static이 붙지 않은 멤버 변수는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속
  - 인스턴스 변수는 인스턴스를 만들 때 마다 새로 만들어짐
- 클래스 변수 : static이 붙은 멤버 변수 -> count
  - 클래스 변수, 정적 변수, static 변수 등으로 부름
  - static이 붙은 멤버 변수는 인스턴스와 무관하게 클래스에 바로 접근해서 사용 가능, 클래스 자체에서 관리 -> 메서드 영역
  - 클래스 변수는 자바 프로그램을 시작할 때 딱 1개가 만들어짐, 여러곳에서 공유하는 목적

변수와 생명주기
- 지역변수(매개변수 포함) : 지역 변수는 스택 영역에 있는 스택 프레임 안에 보관, 메서드가 종료되면 스택 프레임도 제거 -> 해당 스택 프레임이 포함된 지역 변수도 함께 제거됨, 따라서 생존 주기가 짧음
- 인스턴스 변수 : 인스턴스 변수는 힙 영역을 사용, 힙 영역은 GC가 발생하기 전까지는 생존, 따라서 지역 변수보다 생존 주기가 길다
- 클래스 변수 : 메서드 영역의 static 영역에 보관되는 변수, 메서드 영역은 프로그램 전체에서 사용하는 공용공간, 해당 클래스가 JVM에 로딩 되는 순간 생성됨, JVM이 종료될 때 까지 생명주기가 이어지기 때문에 가장 긴 생명주기를 가짐

## 상속
상속은 객체 지향 프로그래밍의 핵심 요소중 하나
기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용 하게 해줌
상속을 사용하려면 extends키워드 사용, extends 대상은 하나만 선택 가능

용어 정리
 - 부모 클래스 (super class) : 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
 - 자식 클래스 (sub class) : 부모 클래스로부터 필드와 메서드를 상속받는 클래스

부모 클래스는 자식 클래스에 접근 불가

단일 상속
자바는 다중 상속을 지원 하지 않음(interface는 다중 구현 가능), 다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해짐, 또 같은 메서드 이름이 있을 경우 어떤 메서드를 사용할지 애매해짐(다이아몬드 문제)

```java
public class Car {

  public void move() {
    System.out.println("차를 이동합니다.");
  }
}

public class ElectricCar extends Car {

  public void charge() {
    System.out.println("충전합니다.");
  }
}

ElectricCar electricCar = new ElectricCar();
```
`new ElectricCar()`를 호출하면 상속 관계에 있는 Car까지 인스턴스를 생성. 참조값은 1개이지만 2가지 클래스 정보가 공존한다.
상속이라고 해서 단순히 부모의 필드와 메서드만 물려 받는게 아니라 부모 클래스도 함께 포함해서 힙 영역에 생성된다.
외부 에서 볼때는 하나의 인스턴스를 생성하는 것 같지만 내부에서는 부모와 자식이 모두 생성되고 공간도 구분된다.

`electricCar.charge()`를 호출하면 참조값 확인 -> ElectricCar의 인스턴스의 `charge()`를 호출, 이때 부모클래스 car를 통해서 charge()를 찾을지 아니면 자식클래스를 통해서 찾을지 선택해야함.
이때는 호출하는 변수의 타입(클래스)을 기준으로 선택, electricCar 변수의 타입이 ElectricCar이므로 인스턴스 내부에 같은 타입인 ElectricCar를 통해서 charge()를 호출

`electricCar.move()`를 호출하면 먼저 호출하는 변수의 타입인 ElectricCar 에서 확인, 없으면 부모클래스 Car로 이동해서 확인하여 move()를 호출한다.

요약
- 상속 관계의 객체를 생성하면 그 내부에는 부모클래스와 자식클래스 모두 생성된다.
- 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
- 현재 타입에서 기능(메서드)을 찾지 못하면 상위 부모 타입으로 이동해 기능을 찾아 실행한다. 기능을 찾지 못하면 컴파일 오류 발생

오버라이딩을 했을 경우에는 해당 자식 클래스에서 메서드를 찾을 수 있으므로 부모 클래스에서 찾지 않는다.

메서드 오버라이딩 조건
- 메서드 이름이 같아야 한다.
- 파라미터 타입, 순서, 개수가 같아야 한다.
- 반환 타입이 같아야 한다. 단 반환 타입이 하위 클래스 타입일 수 있다.
- 접근 제어자가 부모 클래스의 메서드 접근제어자 보다 더 제한적이어서는 안된다.
- 오버라이딩 메서드는 부모 클래스의 메서드보다 더 많은 예외를 throw로 선언할 수 없다, 더 적거나 같은수의 예외, 하위타입의 예외는 선언 가능하다.
- static, final private 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
  - static은 클래스 레벨에서 동작하므로 인스턴스 레벨의 오버라이딩이 의미가 없다.
  - final은 재정의를 금지한다.
  - private은 해당 클래스내에서만 접근 가능하기 때문에 오버라이딩의 대상이 될 수 없다.
- 생성자는 오버라이딩 할 수 없다.

접근 제어와 메모리 구조

자식 클래스에서 메서드를 찾을 수 없을 때 부모 클래스에서 메서드를 찾는데 이때 접근 제어자가 영향을 준다.
힙 영역에서 객체가 구분되어 있기 때문이다. 자식 클래스에서 부모클래스의 기능을 호출할 때 부모 클래스 입장에서는 외부에서 호출한 것과 같기 때문에 접근 제어자가 영향을 준다.

super - 부모 참조

부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어있으면, 자식에서 부모의 필드가 메서드를 호출할 수 없다. 이때 super 키워드를 사용하면 부모 클래스를 참조할 수 있다.

상속 관계의 인스턴스를 생성하면 메모리에는 자식과 부모 클래스 각각 만들어짐 -> 각각의 생성자도 모두 호출

**상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다**

상속 관계에서 부모의 생성자를 호출할 때는 `super(...)`를 사용
`this(...)`를 통해 다른 생성자를 호출하여 생성할때도 언젠가는 반드시 `super(...)`가 호출되어야 한다.